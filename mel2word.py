# -*- coding: utf-8 -*-
"""Mel2Word_module_script

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UJz3q05zYcdhpN6dJeht4a6MX3VeOTUh
"""


import pretty_midi
import numpy as np
from os import listdir
from os.path import isfile, join
from collections import Counter
import pickle


def get_midi(midi_name, melody_program=0):
    """
    Extracts the melody from a MIDI file.

    Parameters:
    - midi_name (str): The name of the MIDI file.
    - melody_program (int, optional): The melody program number of the melody in the MIDI file. Defaults to 0.

    Returns:
    - list: The extracted melody notes.
    """
    midi_data = pretty_midi.PrettyMIDI(midi_name)
    melody = midi_data.instruments[melody_program].notes
    return melody

def get_pitch_interval(melody):
    """
    Calculates pitch intervals from a given melody.

    Parameters:
    - melody (list): The melody notes (pretty_midi).

    Returns:
    - ndarray: Array of pitch intervals.
    """
    pitch = [nt.pitch for nt in melody]
    pitch_interval = np.diff(pitch)
    pitchi = np.clip(pitch_interval, -12, 12)
    return pitchi


def get_IOI(melody, notequantize=0.25):
    """
    Calculates Inter-Onset Intervals (IOIs) from a melody.

    Parameters:
    - melody (list): The melody notes (pretty_midi).
    - notequantize (float, optional): The quantization value for note intervals. Defaults to 0.25.

    Returns:
    - tuple: A tuple containing the array of IOIs and the note quantization value.
    """
    beat = [nt.start for nt in melody]
    beat_interval = np.diff(beat)

    if notequantize is not None:
        beat_interval = notequantize * np.round(beat_interval / notequantize)

    beati = np.clip(beat_interval, 0, 4)
    return beati, notequantize

# Function to convert pitch and IOI to Mel2Word representation
def get_M2W(melody, feat='all'):
    """
    Converts pitch and IOIs of a melody to Mel2Word representation.

    Parameters:
    - melody (list): The melody notes (pretty_midi).
    - feat (str, optional): Feature type to convert ('pitch', 'rhythm', or 'all'). Defaults to 'all'.

    Returns:
    - list: The Mel2Word representation.
    """
    pmidi = get_pitch_interval(melody)
    rtext, quant = get_IOI(melody)
    ptext = [f"U{int(com):02d}" if com > 0 else (f"D{int(-com):02d}" if com < 0 else 'E00') for com in pmidi]

    if quant == 0.25:
        rtext = [f'{int(com * 100):03d}' for com in rtext if com >= 0.25]
    elif quant == 0.125:
        rtext = [f'{int(com * 1000):04d}' for com in rtext]
    else:
        rtext = [f'{int(com * 10000):05d}' for com in rtext]

    alltext = [pt + rt for pt, rt in zip(ptext, rtext)]

    if feat == 'pitch':
        return ptext
    elif feat == 'rhythm':
        return rtext
    elif feat == 'all':
        return alltext


def get_M2W_from_midipath(midipath, feature_option=3):
    """
    Converts a MIDI file to Mel2Word representation based on specified feature options.

    Parameters:
    - midipath (str): The path of the MIDI file.
    - feature_option (int, optional): Option for the feature type to convert (1 for 'pitch', 2 for 'rhythm', 3 for 'all'). Defaults to 3.

    Returns:
    - list: The Mel2Word representation of the MIDI file.
    """
    melody = get_midi(midipath)

    if feature_option == 1:
        m2w_representation = get_M2W(melody, feat='pitch')
    elif feature_option == 2:
        m2w_representation = get_M2W(melody, feat='rhythm')
    elif feature_option == 3:
        m2w_representation = get_M2W(melody, feat='all')
    else:
        print("Invalid feature option. Defaulting to both features.")
        m2w_representation = get_M2W(melody, feat='all')

    return m2w_representation


def load_dictionary(path):
    """
    Load a dictionary from a given file path.

    Parameters:
    - path (str): The file path to the dictionary.

    Returns:
    - dict: The loaded dictionary.
    """
    with open(path, 'rb') as handle:
        return pickle.load(handle)

def get_customed_dictionary(dictionary, dic_size, min_freq=10, max_length=10):
    """
    Build a custom dictionary.

    Parameters:
    - dictionary (dict): The input dictionary containing token occurrences.
    - dic_size (int or str): The desired size of the resulting dictionary; can be an integer or 'Full' for the full size.
    - min_freq (int): The minimum number of occurrences (frequency) for a token to be included in the dictionary.
    - max_length (int): The maximum length (number of tokens) a token can have to be included in the dictionary.

    Returns:
    - dict: The built custom dictionary.
    """
    sorted_vocs = sorted(dictionary.items(), key=lambda t: t[1], reverse=True)
    dic_size = min(dic_size, 100000) if dic_size != 'Full' else 100000

    vocs = {i: dictionary[i] for i, _ in sorted_vocs if len(i.split('_')) <= max_length and len(i.split('_')) > 1 and dictionary[i] > min_freq}

    if dic_size > len(vocs):
        print('Dictionary size too large..Get full-size dictionary of..', len(vocs))
    else:
        print('Getting', dic_size, 'sized dictionary')
    return vocs


def get_M2W_dataset(midi_path):
    """
    Generates a Mel2Word dataset from MIDI files in a specified directory.

    Parameters:
    - midi_path (str): The directory path containing MIDI files.

    Returns:
    - list: A list of dictionaries, each containing Mel2Word data for a MIDI file.
    """
    onlyfiles = [f for f in listdir(midi_path) if isfile(join(midi_path, f))]
    M2W_dataset = []  # List to store dictionaries containing M2W data
    feats = ['pitch', 'rhythm', 'all']  # Features to extract
    error_midi_files = []

    for idx, midi_name in enumerate(onlyfiles):
        midi = {'f_name': midi_name}
        try:
            for feat in feats:
                melody = get_midi(join(midi_path, midi_name))
                # Get M2W representation for the specified feature
                midi['M2W_' + feat] = get_M2W(melody, feat)

            M2W_dataset.append(midi)
            if (idx + 1) % 100 == 0:
                print(idx + 1, 'of', len(onlyfiles), 'files..')

        except Exception as e:
            print('ERROR ON', midi_name, '..skipping the file..')
            error_midi_files.append(midi_name)

    print('Done..for', len(M2W_dataset), 'files..with', len(error_midi_files), 'ERRORS')
    return M2W_dataset


def BPE(db, feat=3, dic_size=100, min_freq=10, max_length=11):
    """
    Builds a dictionary using Byte-Pair Encoding on a given dataset.

    Parameters:
    - db (list): The dataset containing M2W representations for each MIDI file.
    - feat (int, optional): The feature to consider for byte-pair encoding (1 for 'pitch', 2 for 'rhythm', 3 for 'all'). Defaults to 3.
    - dic_size (int, optional): The desired size of the resulting byte-pair dictionary. Defaults to 100.
    - min_freq (int, optional): The minimum frequency threshold for byte-pairs to be considered during dictionary construction. Defaults to 10.
    - max_length (int, optional): The maximum length of byte-pairs to be considered during dictionary construction. Defaults to 11.

    Returns:
    - dict: The generated dictionary.
    """
    words = []

    feat_mapping = {1: 'pitch', 2: 'rhythm', 3: 'all'}
    feat_str = feat_mapping.get(feat, 'all')

    # Concatenate M2W representations for the specified feature
    for mid in db:
        words += mid['M2W_' + feat_str]

    bpvocs = len(Counter(words).keys())
    print('starting byte-paring with iteration of..', dic_size, 'for', feat_str)

    db, bp_stat = prep_for_bytepair(db, feat_str)

    while True:
        # Get the most frequent byte-pair
        bpword, pre_freq = get_bped_word(db, 'bped', bp_stat, max_length)

        # Break the loop if the frequency is below the specified minimum
        if pre_freq <= min_freq:
            break

        tfreq = 0

        # Apply the byte-pair encoding to each MIDI in the dataset
        for midi in db:
            midi['bped'], freq = encode_bytepair(midi['bped'], bpword)
            tfreq += freq

        bp_stat[bpword] = tfreq
        vocsize = len(bp_stat)

        if vocsize % 100 == 0:
            print(vocsize, 'done...')

        if vocsize == dic_size:
            dictionary = {}
            dictionary.update(bp_stat)
            dictionary.update(dict(Counter(words)))
            break

    dictionary = {}
    dictionary.update(bp_stat)
    dictionary.update(dict(Counter(words)))
    dictionary = {k: v for k, v in sorted({**bp_stat, **Counter(words)}.items(), key=lambda item: item[1], reverse=True)}


    print('Dictionary size too large..building dic with Full-size of', len(dictionary) - bpvocs, 'tokens')
    print('new BPE dictionary was built with', len(dictionary) - bpvocs, 'of tokens and', bpvocs, 'of Morpheme-M2W)')

    return dictionary


def encode_bytepair(seq, target_pair):
    """
    Encodes a given sequence by replacing a specified byte-pair with a single token.

    Parameters:
    - seq (list): The sequence to be encoded.
    - target_pair (str): The byte-pair to be encoded.

    Returns:
    - tuple: A tuple containing the encoded sequence and the count of the encoded byte-pair.
    """
    # Encode a byte-pair in the sequence
    for idx in range(len(seq) - 1):
        bp_word = seq[idx] + '_' + seq[idx + 1]

        if target_pair == bp_word:
            bped = '.'.join(seq)
            bped = bped.replace('.' + seq[idx] + '.' + seq[idx + 1] + '.', '.' + target_pair + '.')
            bped = bped.replace('.' + seq[idx] + '.' + seq[idx + 1] + '.', '.' + target_pair + '.')  # to avoid consecutive bp

            # Handle exceptions for the beginning and end of the sequence
            if idx == 0:  # exception (begin)
                bped = bped.replace(seq[idx] + '.' + seq[idx + 1] + '.', target_pair + '.')
            elif idx == len(seq) - 1:  # exception (end)
                bped = bped.replace('.' + seq[idx] + '.' + seq[idx + 1], '.' + target_pair)

            return bped.split('.'), bped.split('.').count(target_pair)

    return seq, 0


def check_bped_word(freq, bp_list):
    """
    Checks if a byte-pair is in the provided list.

    Parameters:
    - freq (list): The frequency list of byte-pairs.
    - bp_list (dict): The list of byte-pairs to check against.

    Returns:
    - tuple: A tuple containing the byte-pair and its frequency.
    """
    for bp in freq:
        if bp[0] not in bp_list.keys():
            return bp[0], bp[1]
    assert 'CHECK ERROR IN BPED WORD'


def get_bped_word(db, mode, bp_list=None, max_bp_len=12):
    """
    Retrieves the most frequent byte-pair from a database.

    Parameters:
    - db (list): The dataset containing M2W representations for each MIDI file.
    - mode (str): The mode of the sequences in the database.
    - bp_list (dict, optional): An existing list of byte-pairs. Defaults to None.
    - max_bp_len (int, optional): The maximum length of a byte-pair. Defaults to 12.

    Returns:
    - tuple: The most frequent byte-pair and its frequency.
    """
    freq = {}

    # Count frequencies of byte-pairs
    for midi in db:
        seq = midi[mode]
        for idx in range(len(seq) - 1):
            bp_word = seq[idx] + '_' + seq[idx + 1]

            if len(bp_word.split('_')) <= max_bp_len:
                freq[bp_word] = freq.get(bp_word, 0) + 1

    # Sort frequencies
    sfreq = sorted(freq.items(), key=lambda t: t[1], reverse=True)

    if bp_list is not None:
        return check_bped_word(sfreq, bp_list)

    return sfreq[0][0], sfreq[0][1]


def prep_for_bytepair(db, feat):
    """
    Prepares a dataset for byte-pair encoding.

    Parameters:
    - db (list): The database to be prepared.
    - feat (str): The feature to be considered in the database.

    Returns:
    - tuple: A tuple containing the prepared database and byte-pair statistics.
    """
    bp_stat = {}

    # Get the initial byte-pair
    bpword, pre_freq = get_bped_word(db, 'M2W_' + feat)

    tfreq = 0

    # Apply the byte-pair encoding to each MIDI in the dataset
    for midi in db:
        midi['bped'], freq = encode_bytepair(midi['M2W_' + feat], bpword)
        tfreq += freq

    bp_stat[bpword] = tfreq
    return db, bp_stat





def get_dictionary_by_occurrence(dictionary, dic_size, min_freq=10, max_length=10):
    """
    Create a dictionary based on token occurrence.

    Parameters:
    - dictionary (dict): The input dictionary with token occurrences.
    - dic_size (int or str): Desired dictionary size (integer or 'Full' for full size).
    - min_freq (int): Minimum token occurrence frequency for inclusion.
    - max_length (int): Maximum token length for inclusion.

    Returns:
    - dict: The generated dictionary based on token occurrence.
    """

    sorted_vocs = sorted(dictionary.items(), key=lambda t: t[1], reverse=True)
    dic_size = min(dic_size, 100000) if dic_size != 'Full' else 100000

    vocs = {i: dictionary[i] for i, _ in sorted_vocs if len(i.split('_')) <= max_length and len(i.split('_')) > 1 and dictionary[i] > min_freq}

    if dic_size > len(vocs):
        print('Dictionary size too large..Get full-size dictionary of..', len(vocs))
    else:
        print('Getting', dic_size, 'sized dictionary')
    return vocs


def get_dictionary_by_length(dictionary, dic_size, min_freq=10, max_length=11):
    """
    Build a dictionary based on length.

    Parameters:
    - dictionary (dict): The input dictionary containing token occurrences.
    - dic_size (int or str): The desired size of the resulting dictionary; can be an integer or 'Full' for the full size.
    - min_freq (int): The minimum number of occurrences (frequency) for a token to be included in the dictionary.
    - max_length (int): The maximum length (number of tokens) a token can have to be included in the dictionary.

    Returns:
    - dict: The built dictionary organized by length.
    """
    vocs = get_dictionary_by_occurrence(dictionary, dic_size, min_freq, max_length)
    maxlen = max(len(i.split('_')) for i in vocs)
    vocdic = {str(lth): [i for i in vocs if len(i.split('_')) == lth] for lth in range(maxlen, 1, -1)}

    print('Dictionary built for', len(vocs), 'tokens')
    return vocdic


def get_M2W_tokens(M2W, dictionary, dic_size=100, feat=3):
    """
    Tokenizes Mel2Word data using a given dictionary.

    Parameters:
    - M2W (list): List of M2W representations to be tokenized.
    - dictionary (dict): The dictionary used for tokenization.
    - dic_size (int, optional): The size of the dictionary to be used. Defaults to 100.
    - feat (int, optional): The feature type (1 for 'pitch', 2 for 'rhythm', 3 for 'all'). Defaults to 3.

    Returns:
    - list: The tokenized Mel2Word data.
    """
    feat_str = None

    M2Wk = min(dictionary, key=dictionary.get)

    if feat == 1:
      feat_str = 'pitch' if not M2W[0][0].isdigit() and not M2Wk[0][0].isdigit()  else None
    elif feat == 2:
      feat_str = 'rhythm' if M2W[0][0].isdigit() and M2Wk[0][0].isdigit() else None
    elif feat == 3:
        feat_str = 'all' if len(M2Wk[0]) > 3 and not M2W[0][0].isdigit() else None
    else:
        print("Error!!: Please check the feat value.")
        return None

    if feat_str is not None:
        print(f"Processing Dictionary for {feat_str} Feature")

        if feat_str == 'pitch':
            print('Tokenization for Pitch Feature..')
        elif feat_str == 'rhythm':
            print('Tokenization for Rhythm Feature..')

        dic = get_dictionary_by_length(dictionary, dic_size)
        dic['1'] = []
        indices = []
        midi = M2W.copy()
        lths = list(dic.keys())
        lentmp = int(lths[0])
        cc = 0
        voc_dic = []

        for mlen in dic:
            for vocss in dic[mlen]:
                for idx, voctmp in enumerate(midi):
                    vocstmp = midi[idx:idx + lentmp]
                    mvocs = ('_').join(vocstmp)
                    if vocss == mvocs:
                        vocstmp = [str(cc) + '.' + s + '.' + str(mlen) for s in vocstmp]
                        midi[idx:idx + lentmp] = vocstmp
                        cc = cc + 1
                        voc_dic.append(vocstmp)
            lentmp = lentmp - 1

        try:
            itr = int(voc_dic[-1][1].split('.')[0])
            for ct in range(0, itr + 1):
                for idx, voc in enumerate(midi):
                    if not voc == 'none':
                        if len(voc.split('.')) == 3:
                            cnt = str(ct)
                            try:
                                lth = int(voc.split('.')[-1])
                            except:
                                pdb.set_trace()
                            if voc[0] == cnt:
                                voc_tmp = []
                                for i in range(lth):
                                    voc_tmp.append((midi[idx + i].split('.')[1]))

                                del midi[idx:idx + lth]

                                for i in range(lth):
                                    if i == 0:
                                        midi.insert(idx, ('_').join(voc_tmp))
                                    else:
                                        midi.insert(idx + i, 'none')

        except:
            print('Nothing to tokenize..(Check the dictionary feature properties.)')

        assert len(midi) == len(M2W)
        midi = [i for i in midi if i != 'none']
        M2Wtoken = midi
        return M2Wtoken

    else:
        print("Error!!: Please check the feature options.")
        print("See examples-", "Mel2Word Example:", M2W[0], "Dictionary Example:",M2Wk)

        return None